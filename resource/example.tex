\section{Examples}

\subsection{Writing a test}

To define a \italic{test case}, simply initialize a variable in a namespace scope with whatever
\code{test::unit()} function returns -- what it is does not matter -- everything happens during
dynamic initialization of that variable (there can be more than one in the same translation unit).
\begin{verbatim}
    1   #include <void_test.hpp>
    2
    3   auto var = test::unit("unit", []() {});
\end{verbatim}
The purpose of a \italic{unit} is to define a context for assertions and other test-related
utilities. Every \italic{unit} has its name and a lambda which gets executed with it. Units
\bold{can be nested}, they \bold{catch any unhandled exceptions} and
\bold{are executed sequentially} as they appear in the source code.
\begin{verbatim}
    1   #include <void_test.hpp>
    2
    3   auto test_case = test::unit("unit", []() {
    4       test::unit("operator+", [](){
    5           test::check(2 + 2 == 4);
    6           test::check_equal(1.5 + 2.0, 3.5);
    7       });
    8       test::unit("operator-", [](){
    9           test::check(2 - 2 == 0);
   10           test::check(1.5 - 2.0 == -0.5);
   11       });
   12   });
\end{verbatim}
All assertions return \code{true} if they passed and \code{false} otherwise. They are \bold{not}
thread-safe and they modify the internal state of the framework. If an assertion fails or something
else goes wrong, the test will return \code{1}. If \voidtest\ itself fails to initialize some
globals, \code{2} is returned. By default, the implicitly defined \code{main} returns \code{0}.

\subsection{Testing container classes}

A (perhaps) unique feature of \voidtest\ is a completely UB-based way of ensuring proper resource
management by RAII classes through the \code{test::object} type. The way it works is by checking
and overwriting certain areas in memory during calls to its special member functions and deciding
whether or not a call was ``valid'' based on gathered information. Because reading from
uninitialized fields during object construction is, as mentioned earlier, the very definition of
\italic{undefined behavior}, it is \bold{highly recommended} to run the test suite before using this
type. For a complete list of supported platforms, take a look at the \italic{Github Actions} section
of the project's repository.
\begin{verbatim}
    1   #include <void_test.hpp>
    2   #include <vector>
    3
    4   using test::object;
    5
    6   auto test_case = test::unit("std::vector", []() {
    7       test::unit("insert()", []() {
    8           auto vector = std::vector<object>(64, 16);
    9           test::check(vector.size() == 64);
   10           test::check(vector.capacity() == 64);
   11           vector.insert(vector.begin() + 5, 8);
   12           test::check_equal(vector[4], 16);
   13           test::check_equal(vector[5], 8);
   14           test::check_equal(vector[6], 16);
   15           test::check_greater(vector.capacity(), 65);
   16       });
   17   });
\end{verbatim}
The \code{test::object} type is constructible from and implicitly convertible to an \code{int}.
If the \code{std::vector} above forgot to destroy a certain number of objects, tried to copy-assign
an object to an uninitialized memory or did something else stupid, \code{test::object} would have
reported it and failed the test. Keep in mind that this is just a low-effort auxiliary tool, do not
rely on it exclusively when testing your containers.

\subsection{Generating random numbers and ranges}
Getting some random data to work with might be useful for \italic{fuzz testing} so \voidtest\
supports it to an extent.
\begin{verbatim}
    1   #include <void_test.hpp>
    2
    3   namespace cpp {
    4
    5       template <typename T>
    6       auto bubble_sort(T first, T last) -> void {
    7           for (auto x = last - 1; x >= first; --x) {
    8               for (auto y = first; y < x; ++y) {
    9                   if (y[0] > y[1]) {
   10                       y[0] ^= y[1];
   11                       y[1] ^= y[0];
   12                       y[0] ^= y[1];
   13                   }
   14               }
   15           }
   16       }
   17
   18   }
   19
   20   auto test_case = test::unit("unit", []() {
   21       auto range = test::range<int>::random(32, 16, 48);
   22       cpp::bubble_sort(range.begin(), range.end());
   23       test::check_sorted(range.begin(), range.end(),
   24           [](int x, int y){ return x <= y; });
   25   });
\end{verbatim}
The \code{test::range<int>} and \code{test::range<float>} classes simulate an
\code{std::vector}-like container and use \code{test::generator<int>} and
\code{test::generator<float>} respectively to generate numbers. Ultimately all of them call member
functions of \code{std::random\_device}, \code{std::uniform\_int\_distribution} and
\code{std::uniform\_real\_distribution}.

\subsection{Reading console output}

Messages printed to the terminal are colored using ANSI escape codes.
Here is how they might look like after running the code from \italic{Writing a test} section:
\begin{verbatim}
    (unit unit)
      (unit operator+)
        (ok check)
        (ok check_equal)
        (test ok [0/2])
      (unit operator-)
        (ok check)
        (ok check)
        (test ok [0/2])
\end{verbatim}
Every nested unit increases the indentation for everything following it by a few spaces. Because
\voidtest\ does not use macros, printing out every assertion whether it failed or not is as good as
it gets when it comes to figuring out where it is located in the source code. For a complete guide on
how to decode more obscure lines such as \code{(test ok [0/2])} see \italic{Reference} section.
